<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>RjDj-like Reactive Music Web</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --accent-color: #38bdf8;
      --accent-soft: rgba(56, 189, 248, 0.24);
    }
    * {
      box-sizing: border-box;
    }
    body {
      font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
      margin: 0;
      padding: 0;
      background: radial-gradient(circle at top, #0f172a, #020617);
      color: #f9fafb;
    }
    .app {
      max-width: 900px;
      margin: 0 auto;
      padding: 24px 16px 40px;
    }
    h1 {
      font-size: 1.7rem;
      margin-bottom: 6px;
    }
    .subtitle {
      font-size: 0.9rem;
      color: #9ca3af;
      margin-bottom: 16px;
      line-height: 1.5;
    }
    .card {
      background: rgba(15, 23, 42, 0.94);
      border-radius: 18px;
      padding: 16px 14px 18px;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.45);
      border: 1px solid var(--accent-soft);
      position: relative;
      overflow: hidden;
    }
    .card::before {
      content: "";
      position: absolute;
      inset: -40%;
      background: radial-gradient(circle at top, rgba(255,255,255,0.08), transparent);
      opacity: 0.6;
      pointer-events: none;
    }
    .card-inner {
      position: relative;
      z-index: 1;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      margin-bottom: 8px;
    }
    button, select {
      font: inherit;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      padding: 6px 14px;
      background: rgba(15, 23, 42, 0.95);
      color: #f9fafb;
      cursor: pointer;
      outline: none;
    }
    button[disabled],
    select:disabled {
      opacity: 0.4;
      cursor: default;
    }
    button:hover:not([disabled]) {
      border-color: var(--accent-color);
    }
    label {
      font-size: 0.85rem;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    #status {
      font-size: 0.85rem;
      color: #e5e7eb;
      min-height: 1.6em;
      margin-top: 4px;
      word-break: break-all;
    }
    .hint {
      font-size: 0.8rem;
      color: #9ca3af;
      margin-top: 6px;
      line-height: 1.5;
    }
    .range-group {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
    }
    .range-group label {
      font-size: 0.75rem;
      flex: 1 1 150px;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .range-group input[type="range"] {
      width: 100%;
    }
    #randomizeBtn {
      font-size: 0.8rem;
      padding-inline: 10px;
    }

    .mode-meta {
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 10px 0 8px;
      padding: 6px 10px;
      border-radius: 999px;
      background: radial-gradient(circle at left, rgba(15,23,42,0.9), rgba(15,23,42,0.7));
      border: 1px solid rgba(148,163,184,0.4);
    }
    .mode-icon {
      width: 28px;
      height: 28px;
      border-radius: 999px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.1rem;
      background: rgba(15,23,42,0.95);
      box-shadow: 0 0 0 1px var(--accent-soft);
    }
    .mode-text {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .mode-name {
      font-size: 0.9rem;
      font-weight: 600;
    }
    .mode-seed {
      font-size: 0.75rem;
      color: #9ca3af;
    }

    .pad {
      position: relative;
      margin-top: 10px;
      border-radius: 16px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: radial-gradient(circle at top left, rgba(15,23,42,0.9), rgba(15,23,42,0.7));
      height: 220px;
      overflow: hidden;
      touch-action: none;
    }
    .pad::before {
      content: "";
      position: absolute;
      inset: 0;
      background-image:
        linear-gradient(to right, rgba(148,163,184,0.16) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(148,163,184,0.14) 1px, transparent 1px);
      background-size: 25% 100%, 100% 25%;
      opacity: 0.6;
      pointer-events: none;
    }
    .pad-cursor {
      position: absolute;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 2px solid var(--accent-color);
      background: rgba(15,23,42,0.9);
      box-shadow: 0 0 15px rgba(56,189,248,0.7);
      transform: translate(-50%, -50%);
      pointer-events: none;
    }
    .pad-label {
      position: absolute;
      left: 10px;
      bottom: 6px;
      font-size: 0.7rem;
      color: #9ca3af;
      background: rgba(15,23,42,0.9);
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.4);
    }
  </style>
</head>
<body>
  <main class="app">
    <h1>RjDj-like Reactive Music Web</h1>
    <p class="subtitle">
      ãƒã‚¤ã‚¯å…¥åŠ›ã‚’ãã®å ´ã§ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç”Ÿæˆãƒ»å¤‰æ›ã™ã‚‹ãƒ–ãƒ©ã‚¦ã‚¶ç‰ˆ RjDj é¢¨ã‚¢ãƒ—ãƒªã€‚<br />
      ã€ŒRjDj-style Shimmerã€ãƒ¢ãƒ¼ãƒ‰ã§ã€ç’°å¢ƒéŸ³ã‚„å£°ãŒç¾ã—ã„ã‚³ãƒ¼ãƒ‰ã‚¯ãƒ©ã‚¦ãƒ‰ã«æº¶ã‘ã¦ã„ãã¾ã™ã€‚
    </p>

    <section class="card">
      <div class="card-inner">
        <div class="controls">
          <button id="startButton">ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªé–‹å§‹</button>

          <label>
            å…¥åŠ›:
            <select id="inputSelect" disabled>
              <option>æœªå–å¾—</option>
            </select>
          </label>

          <label>
            ã‚·ãƒ¼ãƒ³:
            <select id="sceneSelect"></select>
          </label>

          <button id="randomizeBtn" disabled>ãƒ©ãƒ³ãƒ€ãƒ åŒ–</button>
        </div>

        <div class="mode-meta">
          <div id="modeIcon" class="mode-icon">ğŸ§</div>
          <div class="mode-text">
            <div id="modeName" class="mode-name">Scene</div>
            <div id="modeSeed" class="mode-seed">Seed: -</div>
          </div>
        </div>

        <div id="pad" class="pad">
          <div id="padCursor" class="pad-cursor" style="left:50%; top:50%;"></div>
          <div class="pad-label">ã‚¿ãƒƒãƒãƒ‘ãƒƒãƒ‰ï¼šX=ãƒ”ãƒƒãƒ/ãƒ‘ã‚¿ãƒ¼ãƒ³, Y=æ˜ã‚‹ã•/FX</div>
        </div>

        <div class="range-group">
          <label>
            ãƒªãƒãƒ¼ãƒ–é‡
            <input id="reverbSlider" type="range" min="0" max="1" step="0.01" value="0.6" />
          </label>
          <label>
            ã‚¨ã‚³ãƒ¼é‡
            <input id="delaySlider" type="range" min="0" max="1" step="0.01" value="0.4" />
          </label>
          <label>
            ãƒ©ãƒ³ãƒ€ãƒ åº¦
            <input id="randomSlider" type="range" min="0" max="1" step="0.01" value="0.7" />
          </label>
        </div>

        <div id="status"></div>
        <p class="hint">
          æ‰‹é †ï¼š<br />
          â‘ ã€Œã‚ªãƒ¼ãƒ‡ã‚£ã‚ªé–‹å§‹ã€ã§ãƒã‚¤ã‚¯è¨±å¯ï¼ˆå¿…ãšã‚¤ãƒ¤ãƒ›ãƒ³æ¨å¥¨ï¼‰<br />
          â‘¡ å…¥åŠ›ãƒ‡ãƒã‚¤ã‚¹ï¼ˆæœ¬ä½“ãƒã‚¤ã‚¯ / ã‚¤ãƒ¤ãƒ›ãƒ³ãƒã‚¤ã‚¯ ãªã©ï¼‰ã‚’é¸æŠ<br />
          â‘¢ ã‚·ãƒ¼ãƒ³ã‚’ã€ŒRjDj-style Shimmerã€ã«å¤‰æ›´<br />
          â‘£ é™ã‹ãªç’°å¢ƒã§å°‘ã—å¾…ã£ã¦ã€å£°ã‚’å‡ºã—ãŸã‚Šç‰©éŸ³ã‚’ç«‹ã¦ãŸã‚Šã€ã‚¹ãƒãƒ›ã‚’æŒ¯ã£ãŸã‚Šã€ãƒ‘ãƒƒãƒ‰ã‚’ãªãã‚‹ã¨éŸ³ãŒåå¿œã—ã¾ã™ã€‚<br />
          â€»iPhoneã¯OSä»•æ§˜ã§ã€Œæœ¬ä½“ãƒã‚¤ã‚¯ï¼‹ã‚¤ãƒ¤ãƒ›ãƒ³å‡ºåŠ›ã€ã®å®Œå…¨åˆ†é›¢ãŒã§ããªã„å ´åˆãŒã‚ã‚Šã¾ã™ã€‚
        </p>
      </div>
    </section>
  </main>

  <script type="module">
    // file:// ç›´é–‹ãã¯ãƒã‚¤ã‚¯æ¨©é™ãŒå–ã‚Œãªã„ã®ã§æ³¨æ„
    if (location.protocol === "file:") {
      alert("ã“ã®ã‚¢ãƒ—ãƒªã¯ file:// ã§ã¯å‹•ãã¾ã›ã‚“ã€‚ãƒ­ãƒ¼ã‚«ãƒ«ã‚µãƒ¼ãƒãƒ¼ or GitHub Pages (https) ã§é–‹ã„ã¦ãã ã•ã„ã€‚");
    }

    // ===== DOM =====
    const startButton   = document.getElementById("startButton");
    const sceneSelect   = document.getElementById("sceneSelect");
    const randomizeBtn  = document.getElementById("randomizeBtn");
    const reverbSlider  = document.getElementById("reverbSlider");
    const delaySlider   = document.getElementById("delaySlider");
    const randomSlider  = document.getElementById("randomSlider");
    const statusEl      = document.getElementById("status");
    const inputSelect   = document.getElementById("inputSelect");
    const pad           = document.getElementById("pad");
    const padCursor     = document.getElementById("padCursor");
    const modeIcon      = document.getElementById("modeIcon");
    const modeNameEl    = document.getElementById("modeName");
    const modeSeedEl    = document.getElementById("modeSeed");

    function setStatus(msg) {
      statusEl.textContent = msg || "";
    }

    // ===== Scene meta (UIã®è‰²ãƒ»ã‚¢ã‚¤ã‚³ãƒ³) =====
    const SCENE_META = {
      ambient: { name: "Ambient Reactive",   icon: "ğŸŒŒ", color: "#38bdf8" },
      house:   { name: "House",              icon: "ğŸ ", color: "#f97316" },
      trance:  { name: "Trance",             icon: "âœ¨", color: "#a855f7" },
      rjdj:    { name: "RjDj-style Shimmer", icon: "ğŸŒ€", color: "#ec4899" },
    };

    function applySceneTheme(sceneId) {
      const meta = SCENE_META[sceneId] || { name: "Unknown", icon: "ğŸ§", color: "#38bdf8" };
      document.documentElement.style.setProperty("--accent-color", meta.color);
      document.documentElement.style.setProperty("--accent-soft", meta.color + "3D");
      modeIcon.textContent = meta.icon;
      modeNameEl.textContent = meta.name;
    }

    // ===== Audio globals =====
    let audioCtx   = null;
    let masterGain = null;
    let sceneInput = null;

    let micStream  = null;
    let micSource  = null;
    let inputGain  = null;
    let selectedDeviceId = "";

    // å…¥åŠ›ãƒ¬ãƒ™ãƒ«è§£æ
    let inputAnalyser = null;
    let inputLevel    = 0;
    let inputLevelTimer = null;

    // ã‚°ãƒ­ãƒ¼ãƒãƒ«FX
    let reverbSend    = null;
    let reverbNode    = null;
    let reverbOutGain = null;

    let delaySend     = null;
    let delayNode     = null;
    let delayFeedback = null;
    let delayFilter   = null;
    let delayOutGain  = null;

    // Scene
    let currentScene = null;
    let motionEnabled = false;
    let randomness = parseFloat(randomSlider.value || "0.7");
    let currentSeed = null;

    // Pad
    let padPointerActive = false;

    // ===== Reverb impulse =====
    function createReverbImpulse(ctx, lengthSec = 2.5, decay = 3.0) {
      const rate = ctx.sampleRate;
      const length = Math.floor(lengthSec * rate);
      const impulse = ctx.createBuffer(2, length, rate);
      for (let ch = 0; ch < impulse.numberOfChannels; ch++) {
        const data = impulse.getChannelData(ch);
        for (let i = 0; i < length; i++) {
          const t = i / length;
          const env = Math.pow(1 - t, decay);
          data[i] = (Math.random() * 2 - 1) * env;
        }
      }
      return impulse;
    }

    // ===== BaseScene =====
    class BaseScene {
      constructor(ctx, inputNode, outputNode) {
        this.ctx    = ctx;
        this.input  = inputNode;
        this.output = outputNode;
        this.started = false;
      }
      start() { this.started = true; }
      stop()  { this.started = false; }
      handleMotion(_ev) {}
      handlePointer(_x, _y, _isDown) {}
      randomize(_seed) {}
    }

    // ===== Ambient Scene =====
    class AmbientReactiveScene extends BaseScene {
      constructor(ctx, inputNode, outputNode) {
        super(ctx, inputNode, outputNode);
        this.schedulerId   = null;
        this.nextEventTime = 0;
        this.tempoBpm      = 80;

        this.scaleOptions = [
          [0, 3, 5, 7, 10, 12],
          [0, 2, 4, 7, 9, 12],
          [0, 2, 3, 7, 10, 12],
          [0, 1, 5, 7, 11, 12],
        ];
        this.scaleIndex   = 0;
        this.basePitch    = 220;
        this.touchX       = 0.5;
        this.touchY       = 0.5;
        this.touchDown    = false;
        this.motionAmount = 0;
      }
      start() {
        if (this.started) return;
        super.start();
        const ctx = this.ctx;

        this.micDry = ctx.createGain();
        this.micFx  = ctx.createGain();
        this.micFilter = ctx.createBiquadFilter();
        this.micFilter.type = "bandpass";
        this.micFilter.frequency.value = 1200;
        this.micFilter.Q.value = 1.4;

        this.input.connect(this.micDry);
        this.input.connect(this.micFx);

        this.micDry.gain.value = 0.4;
        this.micFx.gain.value  = 0.9;

        this.micDry.connect(this.output);
        this.micFx.connect(this.micFilter);
        if (reverbSend) this.micFilter.connect(reverbSend);
        if (delaySend)  this.micFilter.connect(delaySend);

        this.nextEventTime = ctx.currentTime + 0.2;
        this.schedulerId = setInterval(() => this.schedule(), 50);
      }
      stop() {
        if (!this.started) return;
        super.stop();
        try { this.micDry.disconnect(); } catch {}
        try { this.micFx.disconnect(); } catch {}
        try { this.micFilter.disconnect(); } catch {}
        if (this.schedulerId) {
          clearInterval(this.schedulerId);
          this.schedulerId = null;
        }
      }
      get scale() {
        return this.scaleOptions[this.scaleIndex] || this.scaleOptions[0];
      }
      schedule() {
        if (!this.started) return;
        const ctx = this.ctx;
        const lookAhead = 0.2;
        while (this.nextEventTime < ctx.currentTime + lookAhead) {
          const prob = 0.2 + randomness * 0.7;
          if (Math.random() < prob) {
            this.triggerGrain(this.nextEventTime);
          }
          const beat = 60 / this.tempoBpm;
          this.nextEventTime += beat * (0.5 + Math.random() * randomness);
        }
      }
      triggerGrain(time) {
        const ctx = this.ctx;
        const osc = ctx.createOscillator();
        const env = ctx.createGain();

        let idx = Math.floor(this.touchX * this.scale.length);
        idx = Math.max(0, Math.min(this.scale.length - 1, idx));

        const semitone = this.scale[idx] + (this.touchDown ? 12 : 0);
        const freq = this.basePitch * Math.pow(2, semitone / 12);
        osc.type = "sine";
        osc.frequency.setValueAtTime(freq, time);

        const baseDur = 0.2;
        const extra = randomness * 0.6;
        const dur = baseDur + extra * (0.3 + this.motionAmount);

        env.gain.setValueAtTime(0, time);
        env.gain.linearRampToValueAtTime(0.9, time + 0.02);
        env.gain.linearRampToValueAtTime(0, time + dur);

        osc.connect(env);
        env.connect(this.output);
        if (reverbSend) env.connect(reverbSend);
        if (delaySend)  env.connect(delaySend);

        osc.start(time);
        osc.stop(time + dur + 0.1);
      }
      handleMotion(ev) {
        if (!this.started || !ev) return;
        const acc = ev.accelerationIncludingGravity || ev.acceleration;
        if (!acc) return;
        const x = acc.x || 0;
        const y = acc.y || 0;
        const z = acc.z || 0;
        const mag = Math.min(Math.sqrt(x*x + y*y + z*z), 30);
        const norm = mag / 30;
        this.motionAmount = norm;

        const minBpm = 60;
        const maxBpm = 120;
        this.tempoBpm = minBpm + norm * (maxBpm - minBpm);

        if (this.micFilter) {
          const minF = 600;
          const maxF = 5000;
          this.micFilter.frequency.value = minF + norm * (maxF - minF);
        }
      }
      handlePointer(xNorm, yNorm, isDown) {
        if (!this.started) return;
        this.touchX = xNorm;
        this.touchY = yNorm;
        this.touchDown = !!isDown;
        if (this.micDry) this.micDry.gain.value = 0.2 + (1 - yNorm) * 0.8;
        if (this.micFx)  this.micFx.gain.value  = 0.3 + yNorm * 0.9;
      }
      randomize(seed) {
        this.scaleIndex = Math.floor(Math.random() * this.scaleOptions.length);
        const baseOptions = [110, 165, 220, 330];
        this.basePitch = baseOptions[Math.floor(Math.random() * baseOptions.length)];
        const jitter = (Math.random() - 0.5) * 20 * randomness;
        this.tempoBpm = 80 + jitter;
      }
    }

    // ===== House Scene =====
    class HouseScene extends BaseScene {
      constructor(ctx, inputNode, outputNode) {
        super(ctx, inputNode, outputNode);
        this.tempoBpm = 124;
        this.stepIndex = 0;
        this.nextEventTime = 0;
        this.schedulerId = null;
        this.touchX = 0.5;
        this.touchY = 0.5;
        this.motionAmount = 0;
        this.bassPattern = [0, null, 7, null, 5, null, 7, null, 3, null, 7, null, 5, null, null, null];

        const length = Math.floor(ctx.sampleRate * 0.2);
        this.noiseBuffer = ctx.createBuffer(1, length, ctx.sampleRate);
        const data = this.noiseBuffer.getChannelData(0);
        for (let i = 0; i < length; i++) data[i] = Math.random() * 2 - 1;
      }
      start() {
        if (this.started) return;
        super.start();
        const ctx = this.ctx;
        this.micFilter = ctx.createBiquadFilter();
        this.micFilter.type = "lowpass";
        this.micFilter.frequency.value = 4000;
        this.micGain = ctx.createGain();
        this.micGain.gain.value = 0.5;
        this.input.connect(this.micFilter);
        this.micFilter.connect(this.micGain);
        this.micGain.connect(this.output);
        if (reverbSend) this.micGain.connect(reverbSend);

        this.nextEventTime = ctx.currentTime + 0.1;
        this.schedulerId = setInterval(() => this.schedule(), 25);
      }
      stop() {
        if (!this.started) return;
        super.stop();
        try { this.micFilter.disconnect(); } catch {}
        try { this.micGain.disconnect(); } catch {}
        if (this.schedulerId) { clearInterval(this.schedulerId); this.schedulerId = null; }
      }
      schedule() {
        if (!this.started) return;
        const ctx = this.ctx;
        const lookAhead = 0.1;
        const beatDur = 60 / this.tempoBpm;
        const stepDur = beatDur / 4;
        while (this.nextEventTime < ctx.currentTime + lookAhead) {
          this.triggerStep(this.stepIndex, this.nextEventTime);
          this.stepIndex = (this.stepIndex + 1) % 16;
          this.nextEventTime += stepDur;
        }
      }
      triggerStep(step, time) {
        if (step % 4 === 0) this.triggerKick(time);
        if (step % 2 === 1) {
          const prob = 0.6 + 0.3 * randomness;
          if (Math.random() < prob) this.triggerHat(time);
        }
        const pitch = this.bassPattern[step];
        if (pitch !== null) this.triggerBass(time, pitch);
      }
      triggerKick(time) {
        const ctx = this.ctx;
        const osc = ctx.createOscillator();
        const env = ctx.createGain();
        osc.type = "sine";
        osc.frequency.setValueAtTime(110, time);
        osc.frequency.exponentialRampToValueAtTime(40, time + 0.08);
        env.gain.setValueAtTime(0.0001, time);
        env.gain.exponentialRampToValueAtTime(1.0, time + 0.005);
        env.gain.exponentialRampToValueAtTime(0.0001, time + 0.25);
        osc.connect(env);
        env.connect(this.output);
        if (reverbSend) env.connect(reverbSend);
        osc.start(time);
        osc.stop(time + 0.3);
      }
      triggerHat(time) {
        const ctx = this.ctx;
        const src = ctx.createBufferSource();
        src.buffer = this.noiseBuffer;
        const hp = ctx.createBiquadFilter();
        hp.type = "highpass";
        hp.frequency.value = 7000 + this.motionAmount * 4000;
        const env = ctx.createGain();
        env.gain.setValueAtTime(0.0001, time);
        env.gain.exponentialRampToValueAtTime(0.5, time + 0.005);
        env.gain.exponentialRampToValueAtTime(0.0001, time + 0.12);
        src.connect(hp);
        hp.connect(env);
        env.connect(this.output);
        if (reverbSend) env.connect(reverbSend);
        src.start(time);
        src.stop(time + 0.15);
      }
      triggerBass(time, patternSemitone) {
        const ctx = this.ctx;
        const osc = ctx.createOscillator();
        const filter = ctx.createBiquadFilter();
        const env = ctx.createGain();
        osc.type = "sawtooth";
        const baseFreq = 55 * Math.pow(2, this.touchX * 2);
        const freq = baseFreq * Math.pow(2, patternSemitone / 12);
        osc.frequency.setValueAtTime(freq, time);
        filter.type = "lowpass";
        const cutoffBase = 400 + this.motionAmount * 2000;
        filter.frequency.setValueAtTime(cutoffBase, time);
        filter.Q.value = 0.8 + randomness * 1.5;
        env.gain.setValueAtTime(0.0001, time);
        env.gain.exponentialRampToValueAtTime(0.9, time + 0.015);
        env.gain.exponentialRampToValueAtTime(0.0001, time + 0.3);
        osc.connect(filter);
        filter.connect(env);
        env.connect(this.output);
        if (reverbSend) env.connect(reverbSend);
        osc.start(time);
        osc.stop(time + 0.35);
      }
      handleMotion(ev) {
        if (!this.started || !ev) return;
        const acc = ev.accelerationIncludingGravity || ev.acceleration;
        if (!acc) return;
        const x = acc.x || 0;
        const y = acc.y || 0;
        const z = acc.z || 0;
        const mag = Math.min(Math.sqrt(x*x + y*y + z*z), 25);
        const norm = mag / 25;
        this.motionAmount = norm;
        const minBpm = 120;
        const maxBpm = 130;
        this.tempoBpm = minBpm + norm * (maxBpm - minBpm);
      }
      handlePointer(xNorm, yNorm) {
        if (!this.started) return;
        this.touchX = xNorm;
        this.touchY = yNorm;
        if (this.micGain) this.micGain.gain.value = 0.3 + (1 - yNorm) * 0.7;
      }
      randomize(seed) {
        const basePattern = [0, null, 7, null, 5, null, 7, null, 3, null, 7, null, 5, null, null, null];
        this.bassPattern = basePattern.map((p) => {
          if (p === null) return null;
          if (Math.random() < randomness * 0.4) {
            return p + (Math.random() < 0.5 ? -12 : 12);
          }
          return p;
        });
        const jitter = (Math.random() - 0.5) * 6 * randomness;
        this.tempoBpm = 124 + jitter;
      }
    }

    // ===== Trance Scene =====
    class TranceScene extends BaseScene {
      constructor(ctx, inputNode, outputNode) {
        super(ctx, inputNode, outputNode);
        this.tempoBpm = 138;
        this.nextEventTime = 0;
        this.stepIndex = 0;
        this.schedulerId = null;
        this.touchX = 0.5;
        this.touchY = 0.5;
        this.motionAmount = 0;
        this.arpeggio = [0, 7, 12, 7];
      }
      start() {
        if (this.started) return;
        super.start();
        const ctx = this.ctx;
        this.micFilter = ctx.createBiquadFilter();
        this.micFilter.type = "lowpass";
        this.micFilter.frequency.value = 5000;
        this.micGain = ctx.createGain();
        this.micGain.gain.value = 0.4;
        this.input.connect(this.micFilter);
        this.micFilter.connect(this.micGain);
        this.micGain.connect(this.output);
        if (reverbSend) this.micGain.connect(reverbSend);
        this.fxTap = ctx.createGain();
        this.input.connect(this.fxTap);
        if (delaySend) this.fxTap.connect(delaySend);
        this.nextEventTime = ctx.currentTime + 0.1;
        this.schedulerId = setInterval(() => this.schedule(), 25);
      }
      stop() {
        if (!this.started) return;
        super.stop();
        try { this.micFilter.disconnect(); } catch {}
        try { this.micGain.disconnect(); } catch {}
        try { this.fxTap.disconnect(); } catch {}
        if (this.schedulerId) { clearInterval(this.schedulerId); this.schedulerId = null; }
      }
      schedule() {
        if (!this.started) return;
        const ctx = this.ctx;
        const lookAhead = 0.12;
        const beatDur = 60 / this.tempoBpm;
        const stepDur = beatDur / 2;
        while (this.nextEventTime < ctx.currentTime + lookAhead) {
          this.triggerStep(this.stepIndex, this.nextEventTime);
          this.stepIndex = (this.stepIndex + 1) % 8;
          this.nextEventTime += stepDur;
        }
      }
      triggerStep(step, time) {
        if (step % 4 === 0) this.triggerKick(time);
        this.triggerClick(time);
        if (step % 2 === 0) {
          const idx = (step / 2) % this.arpeggio.length;
          this.triggerPluck(time, this.arpeggio[idx]);
        }
      }
      triggerKick(time) {
        const ctx = this.ctx;
        const osc = ctx.createOscillator();
        const env = ctx.createGain();
        osc.type = "sine";
        osc.frequency.setValueAtTime(130, time);
        osc.frequency.exponentialRampToValueAtTime(45, time + 0.06);
        env.gain.setValueAtTime(0.0001, time);
        env.gain.exponentialRampToValueAtTime(1.0, time + 0.004);
        env.gain.exponentialRampToValueAtTime(0.0001, time + 0.2);
        osc.connect(env);
        env.connect(this.output);
        if (reverbSend) env.connect(reverbSend);
        osc.start(time);
        osc.stop(time + 0.25);
      }
      triggerClick(time) {
        const ctx = this.ctx;
        const osc = ctx.createOscillator();
        const env = ctx.createGain();
        osc.type = "square";
        osc.frequency.setValueAtTime(8000, time);
        env.gain.setValueAtTime(0.0001, time);
        env.gain.exponentialRampToValueAtTime(0.3, time + 0.002);
        env.gain.exponentialRampToValueAtTime(0.0001, time + 0.05);
        osc.connect(env);
        env.connect(this.output);
        osc.start(time);
        osc.stop(time + 0.08);
      }
      triggerPluck(time, semitone) {
        const ctx = this.ctx;
        const osc1 = ctx.createOscillator();
        const osc2 = ctx.createOscillator();
        const filter = ctx.createBiquadFilter();
        const env = ctx.createGain();
        const baseFreq = 220 * Math.pow(2, this.touchX * 1.5);
        const freq = baseFreq * Math.pow(2, semitone / 12);
        osc1.type = "sawtooth";
        osc2.type = "sawtooth";
        osc1.frequency.setValueAtTime(freq * 0.985, time);
        osc2.frequency.setValueAtTime(freq * 1.015, time);
        filter.type = "lowpass";
        const minCut = 2000, maxCut = 9000;
        const cutoff = minCut + this.motionAmount * (maxCut - minCut);
        filter.frequency.setValueAtTime(cutoff, time);
        filter.Q.value = 1.2 + this.touchY * 4;
        env.gain.setValueAtTime(0.0001, time);
        env.gain.exponentialRampToValueAtTime(0.9, time + 0.01);
        const rel = 0.25 + (1 - this.touchY) * 0.25;
        env.gain.exponentialRampToValueAtTime(0.0001, time + rel);
        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(env);
        env.connect(this.output);
        if (reverbSend) env.connect(reverbSend);
        if (delaySend)  env.connect(delaySend);
        osc1.start(time);
        osc2.start(time);
        osc1.stop(time + rel + 0.1);
        osc2.stop(time + rel + 0.1);
      }
      handleMotion(ev) {
        if (!this.started || !ev) return;
        const acc = ev.accelerationIncludingGravity || ev.acceleration;
        if (!acc) return;
        const x = acc.x || 0, y = acc.y || 0, z = acc.z || 0;
        const mag = Math.min(Math.sqrt(x*x + y*y + z*z), 30);
        const norm = mag / 30;
        this.motionAmount = norm;
        const minBpm = 132, maxBpm = 145;
        this.tempoBpm = minBpm + norm * (maxBpm - minBpm);
      }
      handlePointer(xNorm, yNorm) {
        if (!this.started) return;
        this.touchX = xNorm;
        this.touchY = yNorm;
        if (this.micGain) this.micGain.gain.value = 0.2 + (1 - yNorm) * 0.5;
      }
      randomize(seed) {
        const patterns = [
          [0, 7, 12, 7],
          [0, 5, 10, 5],
          [0, 3, 7, 10],
        ];
        this.arpeggio = patterns[Math.floor(Math.random() * patterns.length)];
        const jitter = (Math.random() - 0.5) * 8 * randomness;
        this.tempoBpm = 138 + jitter;
      }
    }

    // ===== RjDj-style Shimmer Scene =====
    class RjdjShimmerScene extends BaseScene {
      constructor(ctx, inputNode, outputNode) {
        super(ctx, inputNode, outputNode);

        this.tempoBpm      = 90;
        this.nextEventTime = 0;
        this.schedulerId   = null;

        this.padX = 0.5;
        this.padY = 0.5;
        this.motionAmount = 0;

        this.scales = [
          [0, 3, 5, 7, 10],
          [0, 2, 4, 7, 9],
          [0, 2, 5, 7, 9, 12],
        ];
        this.scaleIndex = 0;
        this.rootMidi   = 48;

        const c = this.ctx;

        // mic chain
        this.micHp = c.createBiquadFilter();
        this.micHp.type = "highpass";
        this.micHp.frequency.value = 200;
        this.input.connect(this.micHp);

        this.micDry = c.createGain();
        this.micDry.gain.value = 0.1;
        this.micHp.connect(this.micDry);
        this.micDry.connect(this.output);

        this.micToFxGain = c.createGain();
        this.micToFxGain.gain.value = 0.9;
        this.micHp.connect(this.micToFxGain);

        this.chorusDelay = c.createDelay(0.05);
        this.chorusDelay.delayTime.value = 0.02;
        this.chorusGain = c.createGain();
        this.chorusGain.gain.value = 0.8;
        this.micToFxGain.connect(this.chorusDelay);
        this.chorusDelay.connect(this.chorusGain);

        this.lfo = c.createOscillator();
        this.lfoGain = c.createGain();
        this.lfo.frequency.value = 0.25;
        this.lfoGain.gain.value  = 0.01;
        this.lfo.connect(this.lfoGain);
        this.lfoGain.connect(this.chorusDelay.delayTime);
        this.lfo.start();

        this.tap1 = c.createDelay(2.0);
        this.tap2 = c.createDelay(2.0);
        this.tap1.delayTime.value = 0.35;
        this.tap2.delayTime.value = 0.62;

        this.tap1Filter = c.createBiquadFilter();
        this.tap2Filter = c.createBiquadFilter();
        this.tap1Filter.type = "lowpass";
        this.tap2Filter.type = "lowpass";
        this.tap1Filter.frequency.value = 6000;
        this.tap2Filter.frequency.value = 5000;

        this.tap1Gain = c.createGain();
        this.tap2Gain = c.createGain();
        this.tap1Gain.gain.value = 0.6;
        this.tap2Gain.gain.value = 0.5;

        this.tap1Fb = c.createGain();
        this.tap2Fb = c.createGain();
        this.tap1Fb.gain.value = 0.5;
        this.tap2Fb.gain.value = 0.55;

        this.tap1Pan = c.createStereoPanner();
        this.tap2Pan = c.createStereoPanner();
        this.tap1Pan.pan.value = -0.5;
        this.tap2Pan.pan.value =  0.5;

        this.chorusGain.connect(this.tap1);
        this.chorusGain.connect(this.tap2);

        this.tap1.connect(this.tap1Filter);
        this.tap1Filter.connect(this.tap1Gain);
        this.tap1Gain.connect(this.tap1Pan);
        this.tap1Pan.connect(this.output);
        if (reverbSend) this.tap1Pan.connect(reverbSend);

        this.tap2.connect(this.tap2Filter);
        this.tap2Filter.connect(this.tap2Gain);
        this.tap2Gain.connect(this.tap2Pan);
        this.tap2Pan.connect(this.output);
        if (reverbSend) this.tap2Pan.connect(reverbSend);

        this.tap1Gain.connect(this.tap1Fb);
        this.tap1Fb.connect(this.tap1);
        this.tap2Gain.connect(this.tap2Fb);
        this.tap2Fb.connect(this.tap2);
      }

      get scale() {
        return this.scales[this.scaleIndex] || this.scales[0];
      }

      start() {
        if (this.started) return;
        super.start();
        const c = this.ctx;
        this.nextEventTime = c.currentTime + 0.3;
        this.schedulerId = setInterval(() => this.schedule(), 50);
      }

      stop() {
        if (!this.started) return;
        super.stop();
        if (this.schedulerId) {
          clearInterval(this.schedulerId);
          this.schedulerId = null;
        }
        try {
          this.input.disconnect(this.micHp);
          this.micHp.disconnect();
          this.micDry.disconnect();
          this.micToFxGain.disconnect();
          this.chorusDelay.disconnect();
          this.chorusGain.disconnect();
          this.tap1.disconnect();
          this.tap2.disconnect();
          this.tap1Filter.disconnect();
          this.tap2Filter.disconnect();
          this.tap1Gain.disconnect();
          this.tap2Gain.disconnect();
          this.tap1Fb.disconnect();
          this.tap2Fb.disconnect();
          this.tap1Pan.disconnect();
          this.tap2Pan.disconnect();
        } catch {}
        try { this.lfo.stop(); } catch {}
      }

      schedule() {
        if (!this.started) return;
        const c = this.ctx;
        const lookAhead = 0.25;
        const beat = 60 / this.tempoBpm;

        while (this.nextEventTime < c.currentTime + lookAhead) {
          const level = typeof inputLevel === "number" ? inputLevel : 0;
          const density = 0.1 + randomness * 0.3 + level * 0.9;
          if (Math.random() < density) {
            this.triggerPadNote(this.nextEventTime, level);
          }
          const factor = 0.35 + Math.random() * 0.4 * (1 + this.motionAmount);
          this.nextEventTime += beat * factor;
        }
      }

      triggerPadNote(time, level) {
        const c = this.ctx;
        const osc1 = c.createOscillator();
        const osc2 = c.createOscillator();
        const env  = c.createGain();
        const filter = c.createBiquadFilter();
        const pan = c.createStereoPanner();

        let idx = Math.floor(this.padX * this.scale.length);
        idx = Math.max(0, Math.min(this.scale.length - 1, idx));
        const semitone = this.scale[idx];

        const baseRoot = this.rootMidi + Math.round((this.padY - 0.5) * 12);
        const midi = baseRoot + semitone + (Math.random() < 0.3 ? 12 : 0);
        const freq = 440 * Math.pow(2, (midi - 69) / 12);

        osc1.type = "sine";
        osc2.type = "triangle";
        osc1.frequency.setValueAtTime(freq * 0.99, time);
        osc2.frequency.setValueAtTime(freq * 1.01, time);

        filter.type = "lowpass";
        const minCut = 1000, maxCut = 9000;
        const brightness = this.padY * 0.5 + this.motionAmount * 0.5;
        filter.frequency.setValueAtTime(minCut + brightness * (maxCut - minCut), time);
        filter.Q.value = 0.7 + randomness * 5;

        const amp = 0.2 + level * 0.8;
        env.gain.setValueAtTime(0.0001, time);
        env.gain.exponentialRampToValueAtTime(amp, time + 0.02);
        const sustain = 0.3 + this.padY * 0.5 + randomness * 0.3;
        env.gain.exponentialRampToValueAtTime(0.0001, time + sustain);

        const panPos = (Math.random() - 0.5) * (0.3 + this.motionAmount * 0.7);
        pan.pan.setValueAtTime(panPos, time);

        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(env);
        env.connect(pan);
        pan.connect(this.output);
        if (reverbSend) env.connect(reverbSend);
        if (delaySend)  env.connect(delaySend);

        osc1.start(time);
        osc2.start(time);
        osc1.stop(time + sustain + 0.5);
        osc2.stop(time + sustain + 0.5);
      }

      handleMotion(ev) {
        if (!this.started || !ev) return;
        const acc = ev.accelerationIncludingGravity || ev.acceleration;
        if (!acc) return;
        const x = acc.x || 0, y = acc.y || 0, z = acc.z || 0;
        const mag = Math.min(Math.sqrt(x*x + y*y + z*z), 25);
        const norm = mag / 25;
        this.motionAmount = norm;
        const minBpm = 70, maxBpm = 110;
        this.tempoBpm = minBpm + norm * (maxBpm - minBpm);
        const baseFreq = 0.15 + norm * 0.6;
        this.lfo.frequency.setValueAtTime(baseFreq, this.ctx.currentTime);
      }

      handlePointer(xNorm, yNorm, isDown) {
        if (!this.started) return;
        this.padX = xNorm;
        this.padY = 1 - yNorm;

        const wet = yNorm;
        const now = this.ctx.currentTime;
        if (reverbSend) reverbSend.gain.setValueAtTime(0.3 + wet * 0.9, now);
        if (delaySend)  delaySend.gain.setValueAtTime(0.2 + wet * 0.8, now);

        const fx = 0.4 + (1 - yNorm) * 1.0;
        this.micToFxGain.gain.setValueAtTime(fx, now);

        const dry = 0.05 + yNorm * 0.3;
        this.micDry.gain.setValueAtTime(dry, now);
      }

      randomize(seed) {
        this.scaleIndex = Math.floor(Math.random() * this.scales.length);
        const roots = [36, 40, 43, 48, 52];
        this.rootMidi = roots[Math.floor(Math.random() * roots.length)];
      }
    }

    // ===== ã‚·ãƒ¼ãƒ³ä¸€è¦§ =====
    const AVAILABLE_SCENES = [
      { id: "ambient", name: "Ambient Reactive",   factory: (ctx, input, output) => new AmbientReactiveScene(ctx, input, output) },
      { id: "house",   name: "House",              factory: (ctx, input, output) => new HouseScene(ctx, input, output) },
      { id: "trance",  name: "Trance",             factory: (ctx, input, output) => new TranceScene(ctx, input, output) },
      { id: "rjdj",    name: "RjDj-style Shimmer", factory: (ctx, input, output) => new RjdjShimmerScene(ctx, input, output) },
    ];

    function populateSceneSelect() {
      sceneSelect.innerHTML = "";
      AVAILABLE_SCENES.forEach((s) => {
        const opt = document.createElement("option");
        opt.value = s.id;
        opt.textContent = s.name;
        sceneSelect.appendChild(opt);
      });
      sceneSelect.value = "rjdj"; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§RjDjãƒ¢ãƒ¼ãƒ‰
      applySceneTheme("rjdj");
    }
    populateSceneSelect();

    // ===== Audio graph init =====
    async function createAudioContextIfNeeded() {
      if (audioCtx) return;
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) {
        setStatus("ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯ Web Audio API ã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚");
        throw new Error("Web Audio unsupported");
      }
      audioCtx = new AC({ latencyHint: "interactive" });
      await audioCtx.resume();

      sceneInput = audioCtx.createGain();
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.9;

      sceneInput.connect(masterGain);
      masterGain.connect(audioCtx.destination);

      reverbSend    = audioCtx.createGain();
      reverbNode    = audioCtx.createConvolver();
      reverbOutGain = audioCtx.createGain();
      reverbNode.buffer = createReverbImpulse(audioCtx, 2.8, 3.0);
      reverbSend.connect(reverbNode);
      reverbNode.connect(reverbOutGain);
      reverbOutGain.connect(masterGain);

      delaySend      = audioCtx.createGain();
      delayNode      = audioCtx.createDelay(1.5);
      delayFeedback  = audioCtx.createGain();
      delayFilter    = audioCtx.createBiquadFilter();
      delayOutGain   = audioCtx.createGain();

      delaySend.connect(delayNode);
      delayNode.connect(delayFilter);
      delayFilter.connect(delayOutGain);
      delayOutGain.connect(masterGain);

      delayFilter.type = "lowpass";
      delayFilter.frequency.value = 5000;

      delayFilter.connect(delayFeedback);
      delayFeedback.connect(delayNode);

      applyReverbLevel();
      applyDelayLevel();
    }

    async function setMicDevice(deviceId) {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        setStatus("ãƒã‚¤ã‚¯å…¥åŠ›ã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚");
        throw new Error("getUserMedia unsupported");
      }
      selectedDeviceId = deviceId || "";

      if (micStream) {
        micStream.getTracks().forEach(t => t.stop());
        micStream = null;
      }
      if (micSource) {
        try { micSource.disconnect(); } catch {}
        micSource = null;
      }

      const constraints = {
        audio: {
          echoCancellation: false,
          noiseSuppression: false,
          autoGainControl: false,
        }
      };
      if (selectedDeviceId) {
        constraints.audio.deviceId = { exact: selectedDeviceId };
      }

      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      micStream = stream;
      micSource = audioCtx.createMediaStreamSource(stream);

      if (!inputGain) {
        inputGain = audioCtx.createGain();
        inputGain.gain.value = 1.4;
        inputGain.connect(sceneInput);
      }
      micSource.connect(inputGain);

      if (!inputAnalyser) {
        inputAnalyser = audioCtx.createAnalyser();
        inputAnalyser.fftSize = 256;
        inputAnalyser.smoothingTimeConstant = 0.8;
        inputGain.connect(inputAnalyser);

        const buffer = new Uint8Array(inputAnalyser.fftSize);
        if (inputLevelTimer) clearInterval(inputLevelTimer);
        inputLevelTimer = setInterval(() => {
          if (!inputAnalyser) return;
          inputAnalyser.getByteTimeDomainData(buffer);
          let sum = 0;
          for (let i = 0; i < buffer.length; i++) {
            const v = (buffer[i] - 128) / 128;
            sum += v * v;
          }
          const rms = Math.sqrt(sum / buffer.length);
          inputLevel = rms;
        }, 50);
      }
    }

    async function populateInputDevices() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
        inputSelect.innerHTML = "<option>æœªå¯¾å¿œ</option>";
        inputSelect.disabled = true;
        return;
      }
      const devices = await navigator.mediaDevices.enumerateDevices();
      const audioInputs = devices.filter(d => d.kind === "audioinput");
      inputSelect.innerHTML = "";
      const optAny = document.createElement("option");
      optAny.value = "";
      optAny.textContent = "è‡ªå‹•é¸æŠ";
      inputSelect.appendChild(optAny);

      audioInputs.forEach((d, idx) => {
        const opt = document.createElement("option");
        opt.value = d.deviceId;
        opt.textContent = d.label || `ãƒã‚¤ã‚¯ ${idx + 1}`;
        inputSelect.appendChild(opt);
      });

      inputSelect.disabled = false;
      inputSelect.value = selectedDeviceId || "";
    }

    async function initAudioGraphWithDefaultMic() {
      await createAudioContextIfNeeded();
      await setMicDevice(selectedDeviceId);
      await populateInputDevices();
      setStatus("ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªåˆæœŸåŒ–å®Œäº†ã€‚ã‚·ãƒ¼ãƒ³ã‚’é–‹å§‹ã§ãã¾ã™ã€‚");
    }

    // ===== Motion access =====
    async function ensureMotionAccessIfAvailable() {
      if (motionEnabled) return;
      if (typeof DeviceMotionEvent === "undefined") {
        setStatus("åŠ é€Ÿåº¦ã‚»ãƒ³ã‚µãƒ¼éå¯¾å¿œãƒ‡ãƒã‚¤ã‚¹ã§ã™ï¼ˆãƒã‚¤ã‚¯ã®ã¿ã§å‹•ä½œï¼‰ã€‚");
        return;
      }
      if (typeof DeviceMotionEvent.requestPermission === "function") {
        try {
          const res = await DeviceMotionEvent.requestPermission();
          if (res !== "granted") {
            setStatus("ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã‚»ãƒ³ã‚µãƒ¼åˆ©ç”¨ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸã€‚å‹•ãã«ã‚ˆã‚‹å¤‰åŒ–ã¯ã‚ªãƒ•ã«ãªã‚Šã¾ã™ã€‚");
            return;
          }
        } catch (err) {
          console.warn("DeviceMotion permission error:", err);
          setStatus("ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã‚»ãƒ³ã‚µãƒ¼è¨±å¯ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚");
          return;
        }
      }
      window.addEventListener("devicemotion", (ev) => {
        if (currentScene && typeof currentScene.handleMotion === "function") {
          currentScene.handleMotion(ev);
        }
      });
      motionEnabled = true;
    }

    // ===== Padæ“ä½œ =====
    function updatePadCursor(xNorm, yNorm) {
      const clampedX = Math.max(0, Math.min(1, xNorm));
      const clampedY = Math.max(0, Math.min(1, yNorm));
      padCursor.style.left = (clampedX * 100) + "%";
      padCursor.style.top  = (clampedY * 100) + "%";
    }

    function handlePadPointer(ev) {
      if (!currentScene || typeof currentScene.handlePointer !== "function") return;
      const rect = pad.getBoundingClientRect();
      const x = (ev.clientX - rect.left) / rect.width;
      const y = (ev.clientY - rect.top) / rect.height;
      const xNorm = Math.max(0, Math.min(1, x));
      const yNorm = Math.max(0, Math.min(1, y));
      updatePadCursor(xNorm, yNorm);
      const isDown = padPointerActive;
      currentScene.handlePointer(xNorm, yNorm, isDown);
    }

    pad.addEventListener("pointerdown", (ev) => {
      padPointerActive = true;
      pad.setPointerCapture(ev.pointerId);
      handlePadPointer(ev);
    });
    pad.addEventListener("pointermove", (ev) => {
      if (!padPointerActive) return;
      handlePadPointer(ev);
    });
    pad.addEventListener("pointerup", (ev) => {
      padPointerActive = false;
      pad.releasePointerCapture(ev.pointerId);
      handlePadPointer(ev);
    });
    pad.addEventListener("pointercancel", (ev) => {
      padPointerActive = false;
      pad.releasePointerCapture(ev.pointerId);
    });

    // ===== FX sliders =====
    function applyReverbLevel() {
      const v = parseFloat(reverbSlider.value || "0");
      if (reverbSend && reverbOutGain) {
        reverbSend.gain.value = v;
        reverbOutGain.gain.value = 0.5 + v * 0.6;
      }
    }
    function applyDelayLevel() {
      const v = parseFloat(delaySlider.value || "0");
      if (delaySend && delayFeedback && delayOutGain) {
        delaySend.gain.value = v;
        delayOutGain.gain.value = 0.4 + v * 0.7;
        delayFeedback.gain.value = 0.15 + v * 0.65;
      }
    }
    reverbSlider.addEventListener("input", applyReverbLevel);
    delaySlider.addEventListener("input", applyDelayLevel);
    randomSlider.addEventListener("input", () => {
      randomness = parseFloat(randomSlider.value || "0.7");
    });

    // ===== Seed & randomize =====
    function reseedAndRandomize() {
      currentSeed = Math.floor(Math.random() * 1e9);
      modeSeedEl.textContent = "Seed: " + currentSeed;
      if (currentScene && typeof currentScene.randomize === "function") {
        currentScene.randomize(currentSeed);
      }
    }

    // ===== Scene start / switch =====
    function startSelectedScene() {
      if (!audioCtx || !sceneInput || !masterGain) return;
      const id = sceneSelect.value;
      const def = AVAILABLE_SCENES.find(s => s.id === id);
      if (!def) {
        setStatus("ã‚·ãƒ¼ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚");
        return;
      }
      if (currentScene) currentScene.stop();
      applySceneTheme(id);
      currentScene = def.factory(audioCtx, sceneInput, masterGain);
      currentScene.start();
      reseedAndRandomize();
      setStatus(`ã‚·ãƒ¼ãƒ³ã€Œ${def.name}ã€å†ç”Ÿä¸­ã€‚ãƒã‚¤ã‚¯éŸ³ã¨ãƒ‘ãƒƒãƒ‰ï¼å‹•ãã§éŸ³ãŒå¤‰åŒ–ã—ã¾ã™ã€‚`);
    }

    // ===== UI Events =====
    startButton.addEventListener("click", async () => {
      try {
        await initAudioGraphWithDefaultMic();
        await ensureMotionAccessIfAvailable();
        startSelectedScene();
        randomizeBtn.disabled = false;
      } catch (err) {
        console.error(err);
        setStatus("ã‚¨ãƒ©ãƒ¼: " + (err?.message || String(err)));
      }
    });

    sceneSelect.addEventListener("change", () => {
      if (!audioCtx) return;
      startSelectedScene();
    });

    randomizeBtn.addEventListener("click", () => {
      reseedAndRandomize();
      setStatus("ç¾åœ¨ã®ã‚·ãƒ¼ãƒ³ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’Seedã«åŸºã¥ã„ã¦ãƒ©ãƒ³ãƒ€ãƒ åŒ–ã—ã¾ã—ãŸã€‚");
    });

    inputSelect.addEventListener("change", async () => {
      if (!audioCtx) return;
      try {
        const newId = inputSelect.value;
        await setMicDevice(newId);
        setStatus("å…¥åŠ›ãƒ‡ãƒã‚¤ã‚¹ã‚’å¤‰æ›´ã—ã¾ã—ãŸã€‚");
      } catch (err) {
        console.error(err);
        setStatus("å…¥åŠ›ãƒ‡ãƒã‚¤ã‚¹å¤‰æ›´ã§ã‚¨ãƒ©ãƒ¼: " + (err?.message || String(err)));
      }
    });

    setStatus("ã€Œã‚ªãƒ¼ãƒ‡ã‚£ã‚ªé–‹å§‹ã€ã‚’æŠ¼ã—ã¦ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç”Ÿæˆã‚’é–‹å§‹ã—ã¦ãã ã•ã„ã€‚");
  </script>
</body>
</html>
