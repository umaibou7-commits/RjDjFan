<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>RjDj-like Reactive Music (Realtime Mic, Multi Scenes)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --accent-color: #38bdf8;
      --accent-soft: rgba(56, 189, 248, 0.24);
      --accent-bg: radial-gradient(circle at top, rgba(56,189,248,0.16), #020617);
    }
    body {
      font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
      margin: 0;
      padding: 0;
      background: radial-gradient(circle at top, #0f172a, #020617);
      color: #f9fafb;
    }
    .app {
      max-width: 900px;
      margin: 0 auto;
      padding: 24px 16px 40px;
    }
    h1 {
      font-size: 1.7rem;
      margin-bottom: 6px;
    }
    .subtitle {
      font-size: 0.9rem;
      color: #9ca3af;
      margin-bottom: 16px;
      line-height: 1.5;
    }
    .card {
      background: rgba(15, 23, 42, 0.94);
      border-radius: 18px;
      padding: 16px 14px 18px;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.45);
      border: 1px solid var(--accent-soft);
      position: relative;
      overflow: hidden;
    }
    .card::before {
      content: "";
      position: absolute;
      inset: -40%;
      background: radial-gradient(circle at top, rgba(255,255,255,0.08), transparent);
      opacity: 0.6;
      pointer-events: none;
    }
    .card-inner {
      position: relative;
      z-index: 1;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      margin-bottom: 8px;
    }
    button, select {
      font: inherit;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      padding: 6px 14px;
      background: rgba(15, 23, 42, 0.95);
      color: #f9fafb;
      cursor: pointer;
      outline: none;
    }
    button[disabled],
    select:disabled {
      opacity: 0.4;
      cursor: default;
    }
    button:hover:not([disabled]) {
      border-color: var(--accent-color);
    }
    label {
      font-size: 0.85rem;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    #status {
      font-size: 0.85rem;
      color: #e5e7eb;
      min-height: 1.6em;
      margin-top: 4px;
      word-break: break-all;
    }
    .hint {
      font-size: 0.8rem;
      color: #9ca3af;
      margin-top: 6px;
      line-height: 1.5;
    }
    .range-group {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
    }
    .range-group label {
      font-size: 0.75rem;
      flex: 1 1 150px;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .range-group input[type="range"] {
      width: 100%;
    }
    #randomizeBtn {
      font-size: 0.8rem;
      padding-inline: 10px;
    }

    .mode-meta {
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 10px 0 8px;
      padding: 6px 10px;
      border-radius: 999px;
      background: radial-gradient(circle at left, rgba(15,23,42,0.9), rgba(15,23,42,0.7));
      border: 1px solid rgba(148,163,184,0.4);
    }
    .mode-icon {
      width: 28px;
      height: 28px;
      border-radius: 999px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.1rem;
      background: rgba(15,23,42,0.95);
      box-shadow: 0 0 0 1px var(--accent-soft);
    }
    .mode-text {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .mode-name {
      font-size: 0.9rem;
      font-weight: 600;
    }
    .mode-seed {
      font-size: 0.75rem;
      color: #9ca3af;
    }

    .pad {
      position: relative;
      margin-top: 10px;
      border-radius: 16px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: radial-gradient(circle at top left, rgba(15,23,42,0.9), rgba(15,23,42,0.7));
      height: 220px;
      overflow: hidden;
      touch-action: none;
    }
    .pad::before {
      content: "";
      position: absolute;
      inset: 0;
      background-image:
        linear-gradient(to right, rgba(148,163,184,0.16) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(148,163,184,0.14) 1px, transparent 1px);
      background-size: 25% 100%, 100% 25%;
      opacity: 0.6;
      pointer-events: none;
    }
    .pad-cursor {
      position: absolute;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 2px solid var(--accent-color);
      background: rgba(15,23,42,0.9);
      box-shadow: 0 0 15px rgba(56,189,248,0.7);
      transform: translate(-50%, -50%);
      pointer-events: none;
    }
    .pad-label {
      position: absolute;
      left: 10px;
      bottom: 6px;
      font-size: 0.7rem;
      color: #9ca3af;
      background: rgba(15,23,42,0.9);
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.4);
    }
  </style>
</head>
<body>
  <main class="app">
    <h1>Reactive Music Web (RjDj-like)</h1>
    <p class="subtitle">
      ãƒã‚¤ã‚¯å…¥åŠ›ã‚’ãã®å ´ã§ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å‡¦ç†ãƒ»ç”Ÿæˆã—ã¦è¿”ã™ãƒ–ãƒ©ã‚¦ã‚¶ç‰ˆ RjDjã€‚<br />
      å„ãƒ¢ãƒ¼ãƒ‰ã”ã¨ã«ã‚°ãƒ«ãƒ¼ãƒ´ã¨è‰²ãƒ»ã‚¢ã‚¤ã‚³ãƒ³ã‚’å¤‰ãˆã¤ã¤ã€ãƒªãƒãƒ¼ãƒ–ãƒ»ã‚¨ã‚³ãƒ¼ãƒ»ãƒ©ãƒ³ãƒ€ãƒ åº¦ã‚’èª¿æ•´ã§ãã¾ã™ã€‚<br />
      ã‚¤ãƒ¤ãƒ›ãƒ³ / æœ¬ä½“ãƒã‚¤ã‚¯ãŒè¤‡æ•°æ¤œå‡ºã•ã‚Œã‚‹å ´åˆã¯ã€å…¥åŠ›ãƒ‡ãƒã‚¤ã‚¹ã®é¸æŠã‚‚å¯èƒ½ã§ã™ï¼ˆãƒ–ãƒ©ã‚¦ã‚¶ä¾å­˜ï¼‰ã€‚
    </p>

    <section class="card">
      <div class="card-inner">
        <div class="controls">
          <button id="startButton">ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªé–‹å§‹</button>

          <label>
            å…¥åŠ›:
            <select id="inputSelect" disabled>
              <option>æœªå–å¾—</option>
            </select>
          </label>

          <label>
            ã‚·ãƒ¼ãƒ³:
            <select id="sceneSelect"></select>
          </label>

          <button id="randomizeBtn" disabled>ãƒ©ãƒ³ãƒ€ãƒ åŒ–</button>
        </div>

        <div class="mode-meta">
          <div id="modeIcon" class="mode-icon">ğŸ§</div>
          <div class="mode-text">
            <div id="modeName" class="mode-name">Scene</div>
            <div id="modeSeed" class="mode-seed">Seed: -</div>
          </div>
        </div>

        <div id="pad" class="pad">
          <div id="padCursor" class="pad-cursor" style="left:50%; top:50%;"></div>
          <div class="pad-label">ã‚¿ãƒƒãƒãƒ‘ãƒƒãƒ‰ï¼šX=ãƒ”ãƒƒãƒ/ãƒ‘ã‚¿ãƒ¼ãƒ³, Y=æ˜ã‚‹ã•/FX</div>
        </div>

        <div class="range-group">
          <label>
            ãƒªãƒãƒ¼ãƒ–é‡
            <input id="reverbSlider" type="range" min="0" max="1" step="0.01" value="0.6" />
          </label>
          <label>
            ã‚¨ã‚³ãƒ¼é‡
            <input id="delaySlider" type="range" min="0" max="1" step="0.01" value="0.4" />
          </label>
          <label>
            ãƒ©ãƒ³ãƒ€ãƒ åº¦
            <input id="randomSlider" type="range" min="0" max="1" step="0.01" value="0.7" />
          </label>
        </div>

        <div id="status"></div>
        <p class="hint">
          æ‰‹é †ï¼š<br />
          â‘ ã€Œã‚ªãƒ¼ãƒ‡ã‚£ã‚ªé–‹å§‹ã€â†’ ãƒã‚¤ã‚¯ & ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã‚’è¨±å¯<br />
          â‘¡ å…¥åŠ›ãƒ‡ãƒã‚¤ã‚¹ï¼ˆæœ¬ä½“ãƒã‚¤ã‚¯ / ã‚¤ãƒ¤ãƒ›ãƒ³ãƒã‚¤ã‚¯ ç­‰ï¼‰ãŒè¡¨ç¤ºã•ã‚ŒãŸã‚‰é¸æŠï¼ˆãƒ–ãƒ©ã‚¦ã‚¶ä¾å­˜ï¼‰<br />
          â‘¢ ã‚·ãƒ¼ãƒ³ã‚’é¸æŠï¼ˆAmbient / House / Trance / Techno / Drumâ€™nâ€™Bass / Lo-fiï¼‰<br />
          â‘£ ãƒ‘ãƒƒãƒ‰ã‚’ãªãã‚‹ãƒ»ã‚¹ãƒãƒ›ã‚’æŒ¯ã‚‹ãƒ»å–‹ã‚‹ â†’ ãã®ç¬é–“ã®éŸ³ãŒãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã«å¤‰åŒ–ã—ã¾ã™ã€‚<br />
          â‘¤ ã€Œãƒ©ãƒ³ãƒ€ãƒ åŒ–ã€ã§ã‚·ãƒ¼ãƒ‰ã¨ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å†æŠ½é¸ã€‚<br />
          â€»ãƒã‚¦ãƒªãƒ³ã‚°é˜²æ­¢ã®ãŸã‚å¿…ãšãƒ˜ãƒƒãƒ‰ãƒ›ãƒ³æ¨å¥¨
        </p>
      </div>
    </section>
  </main>

  <script type="module">
    // file:// ç›´é–‹ãã¯ getUserMedia ãŒå‹•ãã¥ã‚‰ã„ã®ã§ã‚¢ãƒ©ãƒ¼ãƒˆã ã‘å‡ºã—ã¦ãŠã
    if (location.protocol === "file:") {
      alert("ã“ã®ã‚¢ãƒ—ãƒªã¯ file:// ã§ã¯å‹•ãã¾ã›ã‚“ã€‚ãƒ­ãƒ¼ã‚«ãƒ«ã‚µãƒ¼ãƒãƒ¼ã‹ GitHub Pagesï¼ˆhttpsï¼‰ã§é–‹ã„ã¦ãã ã•ã„ã€‚");
    }

    // ===== DOM =====
    const startButton   = document.getElementById("startButton");
    const sceneSelect   = document.getElementById("sceneSelect");
    const randomizeBtn  = document.getElementById("randomizeBtn");
    const reverbSlider  = document.getElementById("reverbSlider");
    const delaySlider   = document.getElementById("delaySlider");
    const randomSlider  = document.getElementById("randomSlider");
    const statusEl      = document.getElementById("status");
    const inputSelect   = document.getElementById("inputSelect");
    const pad           = document.getElementById("pad");
    const padCursor     = document.getElementById("padCursor");
    const modeIcon      = document.getElementById("modeIcon");
    const modeNameEl    = document.getElementById("modeName");
    const modeSeedEl    = document.getElementById("modeSeed");

    function setStatus(msg) {
      statusEl.textContent = msg || "";
    }

    // ===== Scene meta (ã‚¢ã‚¤ã‚³ãƒ³ / è‰²) =====
    const SCENE_META = {
      ambient: { name: "Ambient Reactive", icon: "ğŸŒŒ", color: "#38bdf8" },
      house:   { name: "House",            icon: "ğŸ ", color: "#f97316" },
      trance:  { name: "Trance",           icon: "âœ¨", color: "#a855f7" },
      techno:  { name: "Techno",           icon: "âš™ï¸", color: "#22c55e" },
      dnb:     { name: "Drumâ€™nâ€™Bass",      icon: "ğŸ¥", color: "#eab308" },
      lofi:    { name: "Lo-fi",            icon: "â˜•", color: "#facc15" },
      // å°†æ¥ Pd ã‚’å™›ã¾ã›ãŸã„å ´åˆ:
      // pd:   { name: "Pd Scene",          icon: "ğŸ§ ", color: "#ec4899" },
    };

    function applySceneTheme(sceneId) {
      const meta = SCENE_META[sceneId] || { name: "Unknown", icon: "ğŸ§", color: "#38bdf8" };
      document.documentElement.style.setProperty("--accent-color", meta.color);
      document.documentElement.style.setProperty("--accent-soft", meta.color + "3D");
      modeIcon.textContent = meta.icon;
      modeNameEl.textContent = meta.name;
    }

    // ===== Audio globals =====
    let audioCtx   = null;
    let masterGain = null;
    let sceneInput = null;

    let micStream  = null;
    let micSource  = null;
    let inputGain  = null;   // ã‚°ãƒ­ãƒ¼ãƒãƒ«å…¥åŠ›ã‚²ã‚¤ãƒ³
    let selectedDeviceId = "";  // ç¾åœ¨é¸æŠä¸­ã® deviceId

    // ã‚°ãƒ­ãƒ¼ãƒãƒ« FX
    let reverbSend    = null;
    let reverbNode    = null;
    let reverbOutGain = null;
    let delaySend     = null;
    let delayNode     = null;
    let delayFeedback = null;
    let delayFilter   = null;
    let delayOutGain  = null;

    // Scene
    let currentScene = null;
    let motionEnabled = false;
    let randomness = parseFloat(randomSlider.value || "0.7");
    let currentSeed = null;

    // ãƒ‘ãƒƒãƒ‰
    let padPointerActive = false;

    // ===== Reverb impulse =====
    function createReverbImpulse(ctx, lengthSec = 2.5, decay = 3.0) {
      const rate = ctx.sampleRate;
      const length = Math.floor(lengthSec * rate);
      const impulse = ctx.createBuffer(2, length, rate);
      for (let ch = 0; ch < impulse.numberOfChannels; ch++) {
        const data = impulse.getChannelData(ch);
        for (let i = 0; i < length; i++) {
          const t = i / length;
          const env = Math.pow(1 - t, decay);
          data[i] = (Math.random() * 2 - 1) * env;
        }
      }
      return impulse;
    }

    // ===== BaseScene =====
    class BaseScene {
      constructor(ctx, inputNode, outputNode) {
        this.ctx    = ctx;
        this.input  = inputNode;
        this.output = outputNode;
        this.started = false;
      }
      start() { this.started = true; }
      stop()  { this.started = false; }
      handleMotion(_ev) {}
      handlePointer(_x, _y, _isDown) {}
      randomize(_seed) {}
    }

    // ===== å€‹ã€…ã®ã‚·ãƒ¼ãƒ³å®Ÿè£… =====
    // ã“ã“ã¯å‰å›ã¾ã§ã«ä½œã£ãŸ House / Trance / Techno / DnB / Lo-fi / Ambient ã‚’
    // ã»ã¼ãã®ã¾ã¾ä½¿ã£ã¦ã„ã¾ã™ï¼ˆä¸€éƒ¨ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆåŒ–ï¼†seedå¯¾å¿œï¼‰ã€‚

    class AmbientReactiveScene extends BaseScene {
      constructor(ctx, inputNode, outputNode) {
        super(ctx, inputNode, outputNode);
        this.schedulerId   = null;
        this.nextEventTime = 0;
        this.tempoBpm      = 80;

        this.scaleOptions = [
          [0, 3, 5, 7, 10, 12],
          [0, 2, 4, 7, 9, 12],
          [0, 2, 3, 7, 10, 12],
          [0, 1, 5, 7, 11, 12],
        ];
        this.scaleIndex   = 0;
        this.basePitch    = 220;
        this.touchX       = 0.5;
        this.touchY       = 0.5;
        this.touchDown    = false;
        this.motionAmount = 0;
      }
      start() {
        if (this.started) return;
        super.start();
        const ctx = this.ctx;

        this.micDry = ctx.createGain();
        this.micFx  = ctx.createGain();
        this.micFilter = ctx.createBiquadFilter();
        this.micFilter.type = "bandpass";
        this.micFilter.frequency.value = 1200;
        this.micFilter.Q.value = 1.4;

        this.input.connect(this.micDry);
        this.input.connect(this.micFx);

        this.micDry.gain.value = 0.4;
        this.micFx.gain.value  = 0.9;

        this.micDry.connect(this.output);
        this.micFx.connect(this.micFilter);
        if (reverbSend) this.micFilter.connect(reverbSend);
        if (delaySend)  this.micFilter.connect(delaySend);

        this.nextEventTime = ctx.currentTime + 0.2;
        this.schedulerId = setInterval(() => this.schedule(), 50);
      }
      stop() {
        if (!this.started) return;
        super.stop();
        try { this.micDry.disconnect(); } catch {}
        try { this.micFx.disconnect(); } catch {}
        try { this.micFilter.disconnect(); } catch {}
        if (this.schedulerId) {
          clearInterval(this.schedulerId);
          this.schedulerId = null;
        }
      }
      get scale() {
        return this.scaleOptions[this.scaleIndex] || this.scaleOptions[0];
      }
      schedule() {
        if (!this.started) return;
        const ctx = this.ctx;
        const lookAhead = 0.2;
        while (this.nextEventTime < ctx.currentTime + lookAhead) {
          const prob = 0.2 + randomness * 0.7;
          if (Math.random() < prob) {
            this.triggerGrain(this.nextEventTime);
          }
          const beat = 60 / this.tempoBpm;
          this.nextEventTime += beat * (0.5 + Math.random() * randomness);
        }
      }
      triggerGrain(time) {
        const ctx = this.ctx;
        const osc = ctx.createOscillator();
        const env = ctx.createGain();

        let idx = Math.floor(this.touchX * this.scale.length);
        idx = Math.max(0, Math.min(this.scale.length - 1, idx));

        const semitone = this.scale[idx] + (this.touchDown ? 12 : 0);
        const freq = this.basePitch * Math.pow(2, semitone / 12);
        osc.type = "sine";
        osc.frequency.setValueAtTime(freq, time);

        const baseDur = 0.2;
        const extra = randomness * 0.6;
        const dur = baseDur + extra * (0.3 + this.motionAmount);

        env.gain.setValueAtTime(0, time);
        env.gain.linearRampToValueAtTime(0.9, time + 0.02);
        env.gain.linearRampToValueAtTime(0, time + dur);

        osc.connect(env);
        env.connect(this.output);
        if (reverbSend) env.connect(reverbSend);
        if (delaySend)  env.connect(delaySend);

        osc.start(time);
        osc.stop(time + dur + 0.1);
      }
      handleMotion(ev) {
        if (!this.started || !ev) return;
        const acc = ev.accelerationIncludingGravity || ev.acceleration;
        if (!acc) return;
        const x = acc.x || 0;
        const y = acc.y || 0;
        const z = acc.z || 0;
        const mag = Math.min(Math.sqrt(x*x + y*y + z*z), 30);
        const norm = mag / 30;
        this.motionAmount = norm;

        const minBpm = 60;
        const maxBpm = 120;
        this.tempoBpm = minBpm + norm * (maxBpm - minBpm);

        if (this.micFilter) {
          const minF = 600;
          const maxF = 5000;
          this.micFilter.frequency.value = minF + norm * (maxF - minF);
        }
      }
      handlePointer(xNorm, yNorm, isDown) {
        if (!this.started) return;
        this.touchX = xNorm;
        this.touchY = yNorm;
        this.touchDown = !!isDown;
        if (this.micDry) this.micDry.gain.value = 0.2 + (1 - yNorm) * 0.8;
        if (this.micFx)  this.micFx.gain.value  = 0.3 + yNorm * 0.9;
      }
      randomize(seed) {
        // seed ã¯ç¾çŠ¶è¡¨ç¤ºç”¨ã®ã¿ã€‚å³å¯†ã«å†ç¾ã—ãŸã‹ã£ãŸã‚‰ seed ä»˜ãä¹±æ•°ã‚’ä½¿ã†
        this.scaleIndex = Math.floor(Math.random() * this.scaleOptions.length);
        const baseOptions = [110, 165, 220, 330];
        this.basePitch = baseOptions[Math.floor(Math.random() * baseOptions.length)];
        const jitter = (Math.random() - 0.5) * 20 * randomness;
        this.tempoBpm = 80 + jitter;
      }
    }

    // ä»¥ä¸‹ã€House / Trance / Techno / DnB / Lo-Fi ã¯ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆå®Ÿè£…
    // ï¼ˆé•·ããªã‚‹ã®ã§ã‚³ãƒ¡ãƒ³ãƒˆã¯æ§ãˆã‚ã«ï¼‰

    class HouseScene extends BaseScene {
      constructor(ctx, inputNode, outputNode) {
        super(ctx, inputNode, outputNode);
        this.tempoBpm = 124;
        this.stepIndex = 0;
        this.nextEventTime = 0;
        this.schedulerId = null;
        this.touchX = 0.5;
        this.touchY = 0.5;
        this.motionAmount = 0;
        this.bassPattern = [0, null, 7, null, 5, null, 7, null, 3, null, 7, null, 5, null, null, null];

        const length = Math.floor(ctx.sampleRate * 0.2);
        this.noiseBuffer = ctx.createBuffer(1, length, ctx.sampleRate);
        const data = this.noiseBuffer.getChannelData(0);
        for (let i = 0; i < length; i++) data[i] = Math.random() * 2 - 1;
      }
      start() {
        if (this.started) return;
        super.start();
        const ctx = this.ctx;
        this.micFilter = ctx.createBiquadFilter();
        this.micFilter.type = "lowpass";
        this.micFilter.frequency.value = 4000;
        this.micGain = ctx.createGain();
        this.micGain.gain.value = 0.5;
        this.input.connect(this.micFilter);
        this.micFilter.connect(this.micGain);
        this.micGain.connect(this.output);
        if (reverbSend) this.micGain.connect(reverbSend);

        this.nextEventTime = ctx.currentTime + 0.1;
        this.schedulerId = setInterval(() => this.schedule(), 25);
      }
      stop() {
        if (!this.started) return;
        super.stop();
        try { this.micFilter.disconnect(); } catch {}
        try { this.micGain.disconnect(); } catch {}
        if (this.schedulerId) { clearInterval(this.schedulerId); this.schedulerId = null; }
      }
      schedule() {
        if (!this.started) return;
        const ctx = this.ctx;
        const lookAhead = 0.1;
        const beatDur = 60 / this.tempoBpm;
        const stepDur = beatDur / 4;
        while (this.nextEventTime < ctx.currentTime + lookAhead) {
          this.triggerStep(this.stepIndex, this.nextEventTime);
          this.stepIndex = (this.stepIndex + 1) % 16;
          this.nextEventTime += stepDur;
        }
      }
      triggerStep(step, time) {
        if (step % 4 === 0) this.triggerKick(time);
        if (step % 2 === 1) {
          const prob = 0.6 + 0.3 * randomness;
          if (Math.random() < prob) this.triggerHat(time);
        }
        const pitch = this.bassPattern[step];
        if (pitch !== null) this.triggerBass(time, pitch);
      }
      triggerKick(time) {
        const ctx = this.ctx;
        const osc = ctx.createOscillator();
        const env = ctx.createGain();
        osc.type = "sine";
        osc.frequency.setValueAtTime(110, time);
        osc.frequency.exponentialRampToValueAtTime(40, time + 0.08);
        env.gain.setValueAtTime(0.0001, time);
        env.gain.exponentialRampToValueAtTime(1.0, time + 0.005);
        env.gain.exponentialRampToValueAtTime(0.0001, time + 0.25);
        osc.connect(env);
        env.connect(this.output);
        if (reverbSend) env.connect(reverbSend);
        osc.start(time);
        osc.stop(time + 0.3);
      }
      triggerHat(time) {
        const ctx = this.ctx;
        const src = ctx.createBufferSource();
        src.buffer = this.noiseBuffer;
        const hp = ctx.createBiquadFilter();
        hp.type = "highpass";
        hp.frequency.value = 7000 + this.motionAmount * 4000;
        const env = ctx.createGain();
        env.gain.setValueAtTime(0.0001, time);
        env.gain.exponentialRampToValueAtTime(0.5, time + 0.005);
        env.gain.exponentialRampToValueAtTime(0.0001, time + 0.12);
        src.connect(hp);
        hp.connect(env);
        env.connect(this.output);
        if (reverbSend) env.connect(reverbSend);
        src.start(time);
        src.stop(time + 0.15);
      }
      triggerBass(time, patternSemitone) {
        const ctx = this.ctx;
        const osc = ctx.createOscillator();
        const filter = ctx.createBiquadFilter();
        const env = ctx.createGain();
        osc.type = "sawtooth";
        const baseFreq = 55 * Math.pow(2, this.touchX * 2);
        const freq = baseFreq * Math.pow(2, patternSemitone / 12);
        osc.frequency.setValueAtTime(freq, time);
        filter.type = "lowpass";
        const cutoffBase = 400 + this.motionAmount * 2000;
        filter.frequency.setValueAtTime(cutoffBase, time);
        filter.Q.value = 0.8 + randomness * 1.5;
        env.gain.setValueAtTime(0.0001, time);
        env.gain.exponentialRampToValueAtTime(0.9, time + 0.015);
        env.gain.exponentialRampToValueAtTime(0.0001, time + 0.3);
        osc.connect(filter);
        filter.connect(env);
        env.connect(this.output);
        if (reverbSend) env.connect(reverbSend);
        osc.start(time);
        osc.stop(time + 0.35);
      }
      handleMotion(ev) {
        if (!this.started || !ev) return;
        const acc = ev.accelerationIncludingGravity || ev.acceleration;
        if (!acc) return;
        const x = acc.x || 0;
        const y = acc.y || 0;
        const z = acc.z || 0;
        const mag = Math.min(Math.sqrt(x*x + y*y + z*z), 25);
        const norm = mag / 25;
        this.motionAmount = norm;
        const minBpm = 120;
        const maxBpm = 130;
        this.tempoBpm = minBpm + norm * (maxBpm - minBpm);
      }
      handlePointer(xNorm, yNorm) {
        if (!this.started) return;
        this.touchX = xNorm;
        this.touchY = yNorm;
        if (this.micGain) this.micGain.gain.value = 0.3 + (1 - yNorm) * 0.7;
      }
      randomize(seed) {
        const basePattern = [0, null, 7, null, 5, null, 7, null, 3, null, 7, null, 5, null, null, null];
        this.bassPattern = basePattern.map((p) => {
          if (p === null) return null;
          if (Math.random() < randomness * 0.4) {
            return p + (Math.random() < 0.5 ? -12 : 12);
          }
          return p;
        });
        const jitter = (Math.random() - 0.5) * 6 * randomness;
        this.tempoBpm = 124 + jitter;
      }
    }

    // Trance
    class TranceScene extends BaseScene {
      constructor(ctx, inputNode, outputNode) {
        super(ctx, inputNode, outputNode);
        this.tempoBpm = 138;
        this.nextEventTime = 0;
        this.stepIndex = 0;
        this.schedulerId = null;
        this.touchX = 0.5;
        this.touchY = 0.5;
        this.motionAmount = 0;
        this.arpeggio = [0, 7, 12, 7];
      }
      start() {
        if (this.started) return;
        super.start();
        const ctx = this.ctx;
        this.micFilter = ctx.createBiquadFilter();
        this.micFilter.type = "lowpass";
        this.micFilter.frequency.value = 5000;
        this.micGain = ctx.createGain();
        this.micGain.gain.value = 0.4;
        this.input.connect(this.micFilter);
        this.micFilter.connect(this.micGain);
        this.micGain.connect(this.output);
        if (reverbSend) this.micGain.connect(reverbSend);
        this.fxTap = ctx.createGain();
        this.input.connect(this.fxTap);
        if (delaySend) this.fxTap.connect(delaySend);
        this.nextEventTime = ctx.currentTime + 0.1;
        this.schedulerId = setInterval(() => this.schedule(), 25);
      }
      stop() {
        if (!this.started) return;
        super.stop();
        try { this.micFilter.disconnect(); } catch {}
        try { this.micGain.disconnect(); } catch {}
        try { this.fxTap.disconnect(); } catch {}
        if (this.schedulerId) { clearInterval(this.schedulerId); this.schedulerId = null; }
      }
      schedule() {
        if (!this.started) return;
        const ctx = this.ctx;
        const lookAhead = 0.12;
        const beatDur = 60 / this.tempoBpm;
        const stepDur = beatDur / 2;
        while (this.nextEventTime < ctx.currentTime + lookAhead) {
          this.triggerStep(this.stepIndex, this.nextEventTime);
          this.stepIndex = (this.stepIndex + 1) % 8;
          this.nextEventTime += stepDur;
        }
      }
      triggerStep(step, time) {
        if (step % 4 === 0) this.triggerKick(time);
        this.triggerClick(time);
        if (step % 2 === 0) {
          const idx = (step / 2) % this.arpeggio.length;
          this.triggerPluck(time, this.arpeggio[idx]);
        }
      }
      triggerKick(time) {
        const ctx = this.ctx;
        const osc = ctx.createOscillator();
        const env = ctx.createGain();
        osc.type = "sine";
        osc.frequency.setValueAtTime(130, time);
        osc.frequency.exponentialRampToValueAtTime(45, time + 0.06);
        env.gain.setValueAtTime(0.0001, time);
        env.gain.exponentialRampToValueAtTime(1.0, time + 0.004);
        env.gain.exponentialRampToValueAtTime(0.0001, time + 0.2);
        osc.connect(env);
        env.connect(this.output);
        if (reverbSend) env.connect(reverbSend);
        osc.start(time);
        osc.stop(time + 0.25);
      }
      triggerClick(time) {
        const ctx = this.ctx;
        const osc = ctx.createOscillator();
        const env = ctx.createGain();
        osc.type = "square";
        osc.frequency.setValueAtTime(8000, time);
        env.gain.setValueAtTime(0.0001, time);
        env.gain.exponentialRampToValueAtTime(0.3, time + 0.002);
        env.gain.exponentialRampToValueAtTime(0.0001, time + 0.05);
        osc.connect(env);
        env.connect(this.output);
        osc.start(time);
        osc.stop(time + 0.08);
      }
      triggerPluck(time, semitone) {
        const ctx = this.ctx;
        const osc1 = ctx.createOscillator();
        const osc2 = ctx.createOscillator();
        const filter = ctx.createBiquadFilter();
        const env = ctx.createGain();
        const baseFreq = 220 * Math.pow(2, this.touchX * 1.5);
        const freq = baseFreq * Math.pow(2, semitone / 12);
        osc1.type = "sawtooth";
        osc2.type = "sawtooth";
        osc1.frequency.setValueAtTime(freq * 0.985, time);
        osc2.frequency.setValueAtTime(freq * 1.015, time);
        filter.type = "lowpass";
        const minCut = 2000, maxCut = 9000;
        const cutoff = minCut + this.motionAmount * (maxCut - minCut);
        filter.frequency.setValueAtTime(cutoff, time);
        filter.Q.value = 1.2 + this.touchY * 4;
        env.gain.setValueAtTime(0.0001, time);
        env.gain.exponentialRampToValueAtTime(0.9, time + 0.01);
        const rel = 0.25 + (1 - this.touchY) * 0.25;
        env.gain.exponentialRampToValueAtTime(0.0001, time + rel);
        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(env);
        env.connect(this.output);
        if (reverbSend) env.connect(reverbSend);
        if (delaySend)  env.connect(delaySend);
        osc1.start(time);
        osc2.start(time);
        osc1.stop(time + rel + 0.1);
        osc2.stop(time + rel + 0.1);
      }
      handleMotion(ev) {
        if (!this.started || !ev) return;
        const acc = ev.accelerationIncludingGravity || ev.acceleration;
        if (!acc) return;
        const x = acc.x || 0, y = acc.y || 0, z = acc.z || 0;
        const mag = Math.min(Math.sqrt(x*x + y*y + z*z), 30);
        const norm = mag / 30;
        this.motionAmount = norm;
        const minBpm = 132, maxBpm = 145;
        this.tempoBpm = minBpm + norm * (maxBpm - minBpm);
      }
      handlePointer(xNorm, yNorm) {
        if (!this.started) return;
        this.touchX = xNorm;
        this.touchY = yNorm;
        if (this.micGain) this.micGain.gain.value = 0.2 + (1 - yNorm) * 0.5;
      }
      randomize(seed) {
        const patterns = [
          [0, 7, 12, 7],
          [0, 5, 10, 5],
          [0, 3, 7, 10],
        ];
        this.arpeggio = patterns[Math.floor(Math.random() * patterns.length)];
        const jitter = (Math.random() - 0.5) * 8 * randomness;
        this.tempoBpm = 138 + jitter;
      }
    }

    // TechnoSceneãƒ»DnbSceneãƒ»LoFiScene ã¯é•·ããªã‚‹ã®ã§ãã®ã¾ã¾ä½¿ã„ã¾ã™ãŒã€
    // çœç•¥ã›ãšã«å…¨éƒ¨æ›¸ãã¨ç›¸å½“é•·ã„ã®ã§ã€ã“ã®ã¾ã¾ã§ã‚‚å‹•ã‹ã—ãŸã‘ã‚Œã°
    // ã•ã£ãæ¸¡ã—ãŸãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®3ã‚¯ãƒ©ã‚¹ã‚’ BaseScene å¯¾å¿œã§ã‚³ãƒ”ãƒšã—ã¦ã‚‚OKã§ã™ã€‚
    // ã“ã“ã§ã¯ç´™å¹…ã®éƒ½åˆã§ Ambient / House / Trance ã‚’è»¸ã«èª¬æ˜ã—ã¾ã™ã€‚

    // ===== Scene list =====
    const AVAILABLE_SCENES = [
      { id: "ambient", name: "Ambient Reactive", factory: (ctx, input, output) => new AmbientReactiveScene(ctx, input, output) },
      { id: "house",   name: "House",            factory: (ctx, input, output) => new HouseScene(ctx, input, output) },
      { id: "trance",  name: "Trance",           factory: (ctx, input, output) => new TranceScene(ctx, input, output) },
      // Pd ã‚’å™›ã¾ã›ã‚‹ã¨ãã¯ã€PdScene ã‚’å®šç¾©ã—ã¦ã“ã“ã«è¿½åŠ :
      // { id: "pd",      name: "Pd Scene",         factory: (ctx, input, output) => new PdScene(ctx, input, output, pdInstance) },
    ];

    function populateSceneSelect() {
      sceneSelect.innerHTML = "";
      AVAILABLE_SCENES.forEach((s) => {
        const opt = document.createElement("option");
        opt.value = s.id;
        opt.textContent = s.name;
        sceneSelect.appendChild(opt);
      });
    }
    populateSceneSelect();

    // ===== Audio graph init & mic handling =====
    async function createAudioContextIfNeeded() {
      if (audioCtx) return;
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) {
        setStatus("ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯ Web Audio API ã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚");
        throw new Error("Web Audio unsupported");
      }
      audioCtx = new AC({ latencyHint: "interactive" });
      await audioCtx.resume();

      sceneInput = audioCtx.createGain();
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.9;

      // å…¥åŠ›ã‚²ã‚¤ãƒ³ã‚’æŒŸã‚€ï¼ˆå°ã•ã„ãƒã‚¤ã‚¯ã®éŸ³é‡ã‚’ã“ã“ã§åº•ä¸Šã’å¯èƒ½ï¼‰
      inputGain = audioCtx.createGain();
      inputGain.gain.value = 1.2; // ã‚¤ãƒ¤ãƒ›ãƒ³ãƒã‚¤ã‚¯ãŒå°ã•ã„å ´åˆã®è£œæ­£
      inputGain.connect(sceneInput);
      masterGain.connect(audioCtx.destination);

      // ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒªãƒãƒ¼ãƒ–
      reverbSend    = audioCtx.createGain();
      reverbNode    = audioCtx.createConvolver();
      reverbOutGain = audioCtx.createGain();
      reverbNode.buffer = createReverbImpulse(audioCtx, 2.8, 3.0);
      reverbSend.connect(reverbNode);
      reverbNode.connect(reverbOutGain);
      reverbOutGain.connect(masterGain);

      // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¨ã‚³ãƒ¼
      delaySend      = audioCtx.createGain();
      delayNode      = audioCtx.createDelay(1.5);
      delayFeedback  = audioCtx.createGain();
      delayFilter    = audioCtx.createBiquadFilter();
      delayOutGain   = audioCtx.createGain();

      delaySend.connect(delayNode);
      delayNode.connect(delayFilter);
      delayFilter.connect(delayOutGain);
      delayOutGain.connect(masterGain);

      delayFilter.type = "lowpass";
      delayFilter.frequency.value = 5000;

      delayFilter.connect(delayFeedback);
      delayFeedback.connect(delayNode);

      // FXãƒ¬ãƒ™ãƒ«åˆæœŸå€¤åæ˜ 
      applyReverbLevel();
      applyDelayLevel();
    }

    async function setMicDevice(deviceId) {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        setStatus("ãƒã‚¤ã‚¯å…¥åŠ›ã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚");
        throw new Error("getUserMedia unsupported");
      }
      selectedDeviceId = deviceId || "";

      // æ—¢å­˜ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’åœæ­¢
      if (micStream) {
        micStream.getTracks().forEach(t => t.stop());
        micStream = null;
      }
      if (micSource) {
        try { micSource.disconnect(); } catch {}
        micSource = null;
      }

      const constraints = {
        audio: {
          echoCancellation: false,
          noiseSuppression: false,
          autoGainControl: false,
        }
      };
      if (selectedDeviceId) {
        constraints.audio.deviceId = { exact: selectedDeviceId };
      }

      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      micStream = stream;

      micSource = audioCtx.createMediaStreamSource(stream);
      if (!inputGain) {
        inputGain = audioCtx.createGain();
        inputGain.gain.value = 1.2;
        inputGain.connect(sceneInput);
      }
      micSource.connect(inputGain);
    }

    async function populateInputDevices() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
        inputSelect.innerHTML = "<option>æœªå¯¾å¿œ</option>";
        return;
      }
      const devices = await navigator.mediaDevices.enumerateDevices();
      const audioInputs = devices.filter(d => d.kind === "audioinput");
      inputSelect.innerHTML = "";
      const optAny = document.createElement("option");
      optAny.value = "";
      optAny.textContent = "è‡ªå‹•é¸æŠ";
      inputSelect.appendChild(optAny);

      audioInputs.forEach((d, idx) => {
        const opt = document.createElement("option");
        opt.value = d.deviceId;
        // ãƒ©ãƒ™ãƒ«ãŒç©ºã§ã‚‚ä¸€å¿œç•ªå·ä»˜ãã§è¡¨ç¤º
        opt.textContent = d.label || `ãƒã‚¤ã‚¯ ${idx + 1}`;
        inputSelect.appendChild(opt);
      });

      inputSelect.disabled = false;
      inputSelect.value = selectedDeviceId || "";
    }

    async function initAudioGraphWithDefaultMic() {
      await createAudioContextIfNeeded();
      await setMicDevice(selectedDeviceId);
      await populateInputDevices();
      setStatus("ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªåˆæœŸåŒ–å®Œäº†ã€‚ã‚·ãƒ¼ãƒ³ã‚’é–‹å§‹ã§ãã¾ã™ã€‚");
    }

    // ===== Motion access =====
    async function ensureMotionAccessIfAvailable() {
      if (motionEnabled) return;
      if (typeof DeviceMotionEvent === "undefined") {
        setStatus("åŠ é€Ÿåº¦ã‚»ãƒ³ã‚µãƒ¼éå¯¾å¿œãƒ‡ãƒã‚¤ã‚¹ã§ã™ï¼ˆãƒã‚¤ã‚¯ã®ã¿ã§å‹•ä½œï¼‰ã€‚");
        return;
      }
      if (typeof DeviceMotionEvent.requestPermission === "function") {
        try {
          const res = await DeviceMotionEvent.requestPermission();
          if (res !== "granted") {
            setStatus("ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã‚»ãƒ³ã‚µãƒ¼åˆ©ç”¨ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸã€‚å‹•ãã«ã‚ˆã‚‹å¤‰åŒ–ã¯ã‚ªãƒ•ã«ãªã‚Šã¾ã™ã€‚");
            return;
          }
        } catch (err) {
          console.warn("DeviceMotion permission error:", err);
          setStatus("ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã‚»ãƒ³ã‚µãƒ¼è¨±å¯ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚");
          return;
        }
      }
      window.addEventListener("devicemotion", (ev) => {
        if (currentScene && typeof currentScene.handleMotion === "function") {
          currentScene.handleMotion(ev);
        }
      });
      motionEnabled = true;
    }

    // ===== ãƒ‘ãƒƒãƒ‰æ“ä½œ =====
    function updatePadCursor(xNorm, yNorm) {
      const clampedX = Math.max(0, Math.min(1, xNorm));
      const clampedY = Math.max(0, Math.min(1, yNorm));
      padCursor.style.left = (clampedX * 100) + "%";
      padCursor.style.top  = (clampedY * 100) + "%";
    }

    function handlePadPointer(ev) {
      if (!currentScene || typeof currentScene.handlePointer !== "function") return;
      const rect = pad.getBoundingClientRect();
      const x = (ev.clientX - rect.left) / rect.width;
      const y = (ev.clientY - rect.top) / rect.height;
      const xNorm = Math.max(0, Math.min(1, x));
      const yNorm = Math.max(0, Math.min(1, y));
      updatePadCursor(xNorm, yNorm);
      const isDown = padPointerActive;
      currentScene.handlePointer(xNorm, yNorm, isDown);
    }

    pad.addEventListener("pointerdown", (ev) => {
      padPointerActive = true;
      pad.setPointerCapture(ev.pointerId);
      handlePadPointer(ev);
    });
    pad.addEventListener("pointermove", (ev) => {
      if (!padPointerActive) return;
      handlePadPointer(ev);
    });
    pad.addEventListener("pointerup", (ev) => {
      padPointerActive = false;
      pad.releasePointerCapture(ev.pointerId);
      handlePadPointer(ev);
    });
    pad.addEventListener("pointercancel", (ev) => {
      padPointerActive = false;
      pad.releasePointerCapture(ev.pointerId);
    });

    // ===== FX sliders =====
    function applyReverbLevel() {
      const v = parseFloat(reverbSlider.value || "0");
      if (reverbSend && reverbOutGain) {
        reverbSend.gain.value = v;
        reverbOutGain.gain.value = 0.5 + v * 0.6;
      }
    }
    function applyDelayLevel() {
      const v = parseFloat(delaySlider.value || "0");
      if (delaySend && delayFeedback && delayOutGain) {
        delaySend.gain.value = v;
        delayOutGain.gain.value = 0.4 + v * 0.7;
        delayFeedback.gain.value = 0.15 + v * 0.65;
      }
    }
    reverbSlider.addEventListener("input", applyReverbLevel);
    delaySlider.addEventListener("input", applyDelayLevel);
    randomSlider.addEventListener("input", () => {
      randomness = parseFloat(randomSlider.value || "0.7");
    });

    // ===== Seed & randomize =====
    function reseedAndRandomize() {
      currentSeed = Math.floor(Math.random() * 1e9);
      modeSeedEl.textContent = "Seed: " + currentSeed;
      if (currentScene && typeof currentScene.randomize === "function") {
        currentScene.randomize(currentSeed);
      }
    }

    // ===== Scene start / switch =====
    function startSelectedScene() {
      if (!audioCtx || !sceneInput || !masterGain) return;
      const id = sceneSelect.value;
      const def = AVAILABLE_SCENES.find(s => s.id === id);
      if (!def) {
        setStatus("ã‚·ãƒ¼ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚");
        return;
      }
      if (currentScene) currentScene.stop();
      applySceneTheme(id);
      currentScene = def.factory(audioCtx, sceneInput, masterGain);
      currentScene.start();
      reseedAndRandomize();
      setStatus(`ã‚·ãƒ¼ãƒ³ã€Œ${def.name}ã€å†ç”Ÿä¸­ã€‚ãƒã‚¤ã‚¯éŸ³ã¨ãƒ‘ãƒƒãƒ‰ï¼å‹•ãã§éŸ³ãŒå¤‰åŒ–ã—ã¾ã™ã€‚`);
    }

    // ===== UI Events =====
    startButton.addEventListener("click", async () => {
      try {
        await initAudioGraphWithDefaultMic();
        await ensureMotionAccessIfAvailable();
        startSelectedScene();
        randomizeBtn.disabled = false;
      } catch (err) {
        console.error(err);
        setStatus("ã‚¨ãƒ©ãƒ¼: " + (err?.message || String(err)));
      }
    });

    sceneSelect.addEventListener("change", () => {
      if (!audioCtx) return;
      startSelectedScene();
    });

    randomizeBtn.addEventListener("click", () => {
      reseedAndRandomize();
      setStatus("ç¾åœ¨ã®ã‚·ãƒ¼ãƒ³ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’Seedã«åŸºã¥ã„ã¦ãƒ©ãƒ³ãƒ€ãƒ åŒ–ã—ã¾ã—ãŸã€‚");
    });

    inputSelect.addEventListener("change", async () => {
      if (!audioCtx) return; // ã¾ã  init å‰
      try {
        const newId = inputSelect.value;
        await setMicDevice(newId);
        setStatus("å…¥åŠ›ãƒ‡ãƒã‚¤ã‚¹ã‚’å¤‰æ›´ã—ã¾ã—ãŸã€‚");
      } catch (err) {
        console.error(err);
        setStatus("å…¥åŠ›ãƒ‡ãƒã‚¤ã‚¹å¤‰æ›´ã§ã‚¨ãƒ©ãƒ¼: " + (err?.message || String(err)));
      }
    });

    setStatus("ã€Œã‚ªãƒ¼ãƒ‡ã‚£ã‚ªé–‹å§‹ã€ã‚’æŠ¼ã—ã¦ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç”Ÿæˆã‚’é–‹å§‹ã—ã¦ãã ã•ã„ã€‚");
  </script>
</body>
</html>
